from typing import Optional, override

from pydantic import BaseModel, ConfigDict, Field
from muty.pydantic import (
    autogenerate_model_example_by_class,
)


class GulpMappingField(BaseModel):
    """
    defines how to map a single field, including field-specific options.
    """

    model_config = ConfigDict(
        extra="allow",
        json_schema_extra={
            "examples": [
                {
                    "ecs": ["test.mapped"],
                    "extra_doc_with_event_code": "1234",
                    "is_timestamp_chrome": False,
                }
            ]
        },
    )

    ecs: Optional[list[str] | str] = Field(
        None,
        description="one or more ECS field names to map the source field to in the resulting document.",
        min_length=1,
    )
    extra_doc_with_event_code: Optional[str] = Field(
        None,
        description="""
if this is set, the creation of an extra document is triggered with the given `event.code` and `@timestamp` set to this field value.

in this setting, the mapping file should:

- map a **single** field directly as `@timestamp` (to indicate the *main* document)
- set `mapping.event_code` to the *main* event code
- add additional `extra_doc_with_event_code` fields to create further documents with their own event code.

check `mftecmd_csv.json` for an example of this setting.
""",
    )
    is_timestamp_chrome: Optional[bool] = Field(
        False,
        description="if set, the corresponding value is a `webkit timestamp` (from 1601) and will be converted to nanoseconds from the unix epoch.",
    )
    multiplier: Optional[float] = Field(
        None,
        description="if set and > 1, the corresponding value is multiplied by this value.",
    )


class GulpMapping(BaseModel):
    """
    defines a logsource -> gulp document mapping
    """

    model_config = ConfigDict(
        extra="allow",
        json_schema_extra={
            "examples": [
                {
                    "fields": {"field1": {"ecs": ["test.mapped"]}},
                    "description": "test description.",
                    "agent_type": "win_evtx",
                    "event_code": "1234",
                    "allow_prefixed": False,
                    "timestamp_dayfirst": False,
                    "timestamp_yearfirst": True,
                    "timestamp_fuzzy": False,
                }
            ]
        },
    )

    fields: Optional[dict[str, GulpMappingField]] = Field(
        {},
        description="field mappings { raw_field: { GulpMappingField } } to translate a logsource to gulp document.",
    )
    description: Optional[str] = Field(
        None,
        description="if set, mapping's description.",
    )
    agent_type: Optional[str] = Field(
        None,
        description='if set, all documents generated by this mapping have "agent.type" set to this value. either, the plugin is responsible for setting this.',
    )

    event_code: Optional[str] = Field(
        None,
        description='if set, all documents generated by this mapping have "event.code" set to this value (and "gulp.event_code" to the corresponding numeric value). either, the plugin is responsible for setting this.',
    )
    exclude: Optional[list[str]] = Field(
        None,
        description="if set, these fields are ignored and not included in the generated document/s.",
    )
    include: Optional[list[str]] = Field(
        None,
        description="if set, only these fields are processed and included in the generated document/s.",
    )
    timestamp_dayfirst: Optional[bool] = Field(
        None,
        description="controls how timestamp strings are parsed, for advanced usage: if set, in an ambiguous 3-integer date (i.e. 01/05/09) consider 01 as the day (default=dateutil.parser default=False).",
    )
    timestamp_yearfirst: Optional[bool] = Field(
        None,
        description="controls how timestamp strings are parsed, for advanced usage: if set, in an ambiguous 3-integer date (i.e. 01/05/09) consider 01 as the year (default=dateutil.parser default=False).",
    )
    timestamp_fuzzy: Optional[bool] = Field(
        None,
        description="controls how timestamp strings are parsed, for advanced usage: if set, allows parsing of strings like 'Today is January 1, 2047 at 8:21:00AM' (default=dateutil.parser default=False)",
    )
    allow_prefixed: Optional[bool] = Field(
        False,
        description="""
if set, the source field can be prefixed and only the part after the last "_" is used for mapping.
i.e. if in the source document the field is 'this_is_a_field' and the "ecs" has "field".
""",
    )


class GulpMappingFileMetadata(BaseModel):
    """
    metadata for a mapping file.
    """

    model_config = ConfigDict(
        extra="allow", json_schema_extra={"examples": [{"plugin": ["win_evtx", "csv"]}]}
    )

    plugin: list[str] = Field(
        ...,
        description="one or more plugin names that this mapping file is associated with.",
    )


class GulpMappingFile(BaseModel):
    """
    a mapping file, containing one or more GulpMapping objects.
    """

    model_config = ConfigDict(
        extra="allow",
        json_schema_extra={
            "examples": [
                {
                    "mappings": autogenerate_model_example_by_class(GulpMapping),
                    "metadata": autogenerate_model_example_by_class(
                        GulpMappingFileMetadata
                    ),
                }
            ]
        },
    )

    mappings: dict[str, GulpMapping] = Field(
        ...,
        description="defined mappings for this mapping file, key is the `mapping_id`",
        min_length=1,
    )
    metadata: Optional[GulpMappingFileMetadata] = Field(
        ...,
        description="metadata for the mapping file.",
    )
